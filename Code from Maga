library(dplyr)
library(tidyr)
library(stringr)
library(readr)
library(ggplot2)

readData <- function(pathr) {
  
  data_folder <- pathr
  
  # List all files in the folder
  file_list <- list.files(data_folder, full.names = TRUE)
  
  # Initialize an empty list to store data frames
  data_list <- list()
  
  for (file in file_list) {
    
    # Extract the user ID from the file name
    file_name <- basename(file)  # Extract just the file name (without the path)
    user_id <- strsplit(file_name, "_")[[1]][1]  # Split by "_" and take the first part
    
    # Read the data
    data <- read_delim(file, delim = ";", escape_double = FALSE, trim_ws = TRUE, show_col_types = FALSE)
    
    # Dynamically generate the mean column name
    mean_col_name <- paste0("mean_", colnames(data)[5])
    
    # Clean and convert the 5th column
    data <- data %>%
      mutate(!!colnames(data)[5] := as.numeric(
        str_replace_all(
          str_replace_all(.data[[colnames(data)[5]]], ",", "."),  # Replace commas with periods
          "[^0-9eE.-]", ""  # Remove other unwanted characters
        )))
    
     # Check if 'Round_number' exists (i think it will work without this but leaving it here for now)
    if (!"Round_number" %in% colnames(data)) {
      warning(paste("File", basename(file), "does not have a 'Round_number' column. Skipping..."))
      next
    }
    
    # Calculate the average per round
    avg_values_df <- data %>%
      mutate(
        Round_number = abs(as.numeric(Round_number)),  # Ensure 'Round_number' is numeric
        User_ID = user_id  # Add the User_ID column
      ) %>%
      group_by(Round_number) %>%
      summarise(
        !!mean_col_name := mean(.data[[colnames(data)[5]]], na.rm = TRUE),
        User_ID = first(User_ID),  # Keep User_ID in the summarised data
        .groups = "drop"
      )
    
    # Append to list
    data_list[[length(data_list) + 1]] <- avg_values_df
  }
  
  return(data_list)
}
df_list_Dame <- readData("/Users/anikhachatryan/Desktop/VR-Training-Project/Data/rawData/PMD/DameDaten/EmotiBit") 
df_list_Dame

dataCleaning <- function(dataFrame) {
  # Iterate through each column of the data frame
  for (colName in names(dataFrame)) {
    # Check if the column is numeric
    if (is.numeric(dataFrame[[colName]])) {
      # Extract the column
      column <- dataFrame[[colName]]
      
      # Check if the column is entirely zeros
      if (all(column == 0, na.rm = TRUE)) {
        next # Skip this column; leave it as is
      }
      
      # Calculate the mean, excluding 0 and NA
      columnMean <- mean(column[column != 0 & !is.na(column)], na.rm = TRUE)
      
      # Replace 0s and NAs with the mean
      dataFrame[[colName]][column == 0 | is.na(column)] <- columnMean
    }
  }
  # Return the cleaned data frame
  return(dataFrame)
}


#loading the data that's needed from RoundLogs
df_Dame <- roundLogs_Dame %>%
  select(
    User_ID,
    matches("^Answer_Q1"),
    matches("^Answer_Q2"),
    matches("^RMSSD"),
    matches("^SDNN")
    ) 

# View a summary to ensure data is loaded correctly
summary(df_Dame)

df_Linne <- roundLogs_Linne %>%
  select(
    User_ID,
    matches("^Answer_Q1"),
    matches("^Answer_Q2"),
    matches("^RMSSD"),
    matches("^SDNN")
    )  
df_Linne <- df_Linne %>%
  select(
    matches("_R[1-9]$")
    )
summary(df_Linne)

#using our written function for cleaning
cleanDfLinne <- dataCleaning(df_Linne)
cleanDfDame <- dataCleaning(df_Dame)
any(is.na(cleanDfLinne))
any(is.na(cleanDfDame))


#working with EmotiBit from Dame

# Ensure all elements are data frames
# Combine all data frames into one
combined_PMD_Dame <- bind_rows(df_list)

# Ensure all rounds (0 to 8) are present for each User_ID
combined_PMD_Dame <- combined_PMD_Dame %>%
  group_by(User_ID) %>%
  complete(Round_number = 0:8, fill = list(User_ID = NA)) %>%  # Fill missing rounds for each user with NA
  ungroup()

# Combine all PMD columns by Round_number and User_ID
final_PMD_Dame <- combined_PMD_Dame %>%
  group_by(User_ID, Round_number) %>%
  summarise(across(everything(), ~ na.omit(.x)[1], .names = "{.col}"), .groups = "drop") %>%
  mutate(Round_number = Round_number + 1)  # Adjust Round_number to start from 1

# View final result
print(final_PMD_Dame)



#Reshape the Answer_Q... columns from cleanedDfDame to match Round_number
cleanDfDame_long <- cleanDfDame %>%
  pivot_longer(
    cols = matches("_R[1-9]$"),  # Select Answer columns with _R1 to _R9
    names_to = c(".value", "Round_number"),
    names_pattern = "(.*)_R(\\d+)"  # Extract column prefix and round number
  ) %>%
  mutate(Round_number = as.numeric(Round_number))# Ensure round numbers are numeric

#combining the two data frames i have for Dame to get a final df
# Perform a left join based on User_ID and Round_number
combined_data_Dame <- cleanDfDame_long %>%
  left_join(final_PMD_Dame, by = c("User_ID", "Round_number"))

#replacing the NA values for each measurement with the mean per user, so every user gets their mean
combined_data_Dame <- combined_data_Dame %>%
  group_by(User_ID) %>%
  mutate(across(where(is.numeric), ~ ifelse(is.na(.x), mean(.x, na.rm = TRUE), .x), .names = "{.col}")) %>%
  ungroup()

print(combined_data_Dame)

#imo this is the best
#Spearman Correlation Coefficient
#When to Use:
  #If the data is non-normally distributed or has outliers.
#If the relationship is monotonic (i.e., increases or decreases consistently but may not be linear).
#If one or both variables are ordinal (in our case stress answers).
#What It Measures:
  #The strength and direction of a monotonic relationship based on ranks.

#cor between Q1 and HR, pearson, spearman and kendall ( 0.065, 0.55, 0.41)
cor(combined_data_Dame$Answer_Q1, combined_data_Dame$mean_HR, method = "pearson", use = "complete.obs")
cor(combined_data_Dame$Answer_Q1, combined_data_Dame$mean_HR, method = "spearman", use = "complete.obs")
cor(combined_data_Dame$Answer_Q1, combined_data_Dame$mean_HR, method = "kendall", use = "complete.obs")

#this plot looks better i changed it a bit
ggplot(combined_data_Dame, aes(x = Answer_Q1, y = mean_HR)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Correlation between Answer_Q1 and mean_HR")


# Scatter plot with faceting by Round_number
ggplot(combined_data_Dame, aes(x = Answer_Q1, y = mean_HR)) +
  geom_point() +  # Add points
  geom_smooth(method = "lm", se = FALSE, color = "red") +  # Add regression line
  labs(
    title = "Correlation between Answer_Q1 and mean_HR by Round",
    x = "Answer_Q1",
    y = "mean_HR"
  ) +
  facet_wrap(~ Round_number) +  # Facet by round
  theme_minimal()


#trying to make the correlation table

# Select numeric columns (exclude Answer_Q1 and Answer_Q2 temporarily, also round number)
measurement_columns <- combined_data_Dame %>%
  select(where(is.numeric)) %>%
  select(-c(Answer_Q1, Answer_Q2, Round_number)) %>% 
  colnames()

# Compute correlations between Answer_Q1 and each PMD column
cor1 <- combined_data_Dame %>%
  summarise(across(all_of(measurement_columns), ~ cor(Answer_Q1, .x, use = "complete.obs")))
#now with Answer_Q2
cor2 <- combined_data_Dame %>%
  summarise(across(all_of(measurement_columns), ~ cor(Answer_Q2, .x, use = "complete.obs")))

#this is the result, i had to rows one for Q1 one for Q2 and just combined them
combined_tibble <- bind_rows(
  cor1 %>% mutate(Row_Name = "Answer_Q1"),  # Add row name for tibble1
  cor2 %>% mutate(Row_Name = "Answer_Q2")   # Add row name for tibble2
)

# Move Row_Name column to row names (if needed)
final_tibble <- combined_tibble %>%
  select(Row_Name, everything())  # Ensure Row_Name is the first column

# View the final tibble, save it as a csv file
print(final_tibble)
write.csv(final_tibble, "tibble_output.csv", row.names = FALSE)  # Base R



#for the 2nd question "over the rounds"
# Group by round_number and calculate correlation
correlation_per_round <- combined_data_Dame %>%
  group_by(Round_number) %>%
  summarise(
    correlation = cor(Answer_Q1, mean_HR, use = "complete.obs")
  )

print(correlation_per_round)

# Plot correlation values over rounds
ggplot(correlation_per_round, aes(x = Round_number, y = correlation)) +
  geom_line(color = "blue", size = 1.2) +  # Line to show correlation changes
  geom_point(size = 3, color = "red") +  # Points for each round
  scale_x_continuous(breaks = 1:9, limits = c(1, 9)) +
  labs(
    title = "Changes in Correlation between Answer_Q1 and mean_HR over Rounds",
    x = "Round Number",
    y = "Correlation (Pearson)"
  ) +
  theme_minimal()
